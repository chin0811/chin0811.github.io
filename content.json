{"posts":[{"title":"Vue3-使用object.keys渲染資料","text":"在使用v-for渲染資料的時候，偶爾會面臨一個問題：不是所有的data都需要顯示出來。 一般來說，我們渲染的data都是從後端API拉取的資料，以個人資料為例，拿到的資料可能是： 12345678{ &quot;name&quot;:&quot;chin&quot;, &quot;age&quot;:&quot;28&quot;, &quot;sex&quot;:&quot;女&quot;, &quot;phone&quot;:&quot;0900000000&quot;, &quot;address&quot;:&quot;台北府000路&quot;, &quot;type&quot;:&quot;黃金會員&quot;,} 然而實際需要呈現的資料可能只有其中兩三項，這時候善用object.keys就能夠有效的篩選想要呈現的data，而不需要使用v-if來一個一個呈現或是一個一個隱藏。 先建立想要呈現資訊的object12345678let tableHeadList = ref({ &quot;name&quot;:&quot;姓名&quot;, &quot;age&quot;:&quot;年齡&quot;, &quot;sex&quot;:&quot;性別&quot;, // &quot;phone&quot;:&quot;電話號碼&quot;, // &quot;address&quot;:&quot;地址&quot;, // &quot;type&quot;:&quot;類型&quot;,}) 取得Object.keys(tableHeadList)的key值後，渲染{{ data[key] }}123456789101112131415161718&lt;div class=&quot;body&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th v-for=&quot;key in Object.keys(tableHeadList)&quot;&gt; {{ tableHeadList[key] }} &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td v-for=&quot;key in Object.keys(tableHeadList)&quot;&gt; {{ data[key] }} &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 成功將想要呈現的資訊渲染在頁面上 這樣的做法，還有另一項好處，就是如果想要根據不同的條件呈現不同的data，可以透過更改tableHeadList來達到 1234567891011onMounted(async() =&gt; { if(visible == 'A'){ tableHeadList.value = { &quot;name&quot;:&quot;姓名&quot;, &quot;age&quot;:&quot;年齡&quot;, &quot;sex&quot;:&quot;性別&quot;, &quot;phone&quot;:&quot;電話號碼&quot;, &quot;address&quot;:&quot;地址&quot;, } }}) 不過這樣的做法也有其缺點，因為標題的渲染和data的渲染是分開的，所以寬度跟文字寬度不一致的時候就會破版。 這時候，就需要稍微換一下html的結構，把標題和data放置在同一層的div裡面。 12345678910 &lt;div class=&quot;data-box&quot;&gt; &lt;div&gt; &lt;div v-for=&quot;(item,key) in tableHeadList&quot; &gt; &lt;p&gt;{{item}}&lt;/p&gt; &lt;div&gt; &lt;p&gt;{{data[key]}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;","link":"/2023/10/12/Vue3-%E4%BD%BF%E7%94%A8object-keys%E6%B8%B2%E6%9F%93%E8%B3%87%E6%96%99/"},{"title":"VueRouter跳頁置頂","text":"如果沒有特別設定，Vue使用Vue Router跳頁的時候，並不會自動置頂，而是會跳轉到原本瀏覽頁面的位置。 解法為了解決這個問題，可以手動設置router一但被觸發，就自動將畫面滾動到置頂處。在main.js裡面加入這行程式碼，記得要先引用router。 1234import router from &quot;./router&quot;;router.afterEach((to, from, next) =&gt; { window.scrollTo(0, 0);}); 原理討論那麼，為什麼會有這樣的狀況？ 透過Vue Router，我們可以讓我們透過Vue建置的單頁應用程式(SPA) 實現前端路由，但實際上，我們並沒有跳轉到另一個頁面去，我們只是重新渲染了現在這個頁面，所以我們的瀏覽器頁面位置會停留在原來的高度。 MPA與後端路由在多頁應用程式(MPA)，我們透過後端來控制路由，當我們要替換頁面的時候，會跟後端請求一個新的頁面(xxx.html)，後端接收到請求，將使用者的瀏覽器跳轉到另一頁，也因此我們有多頁。 SPA與前端路由Vue Router則是使用了 Html5的History API來控制路由，透過history.pushState()將新的路由狀態添加到瀏覽器的歷史紀錄，然後改變網址。但我們沒有請求一個新的頁面，也沒有創造出一個新的頁面，而是在原本的頁面渲染出不同的資料畫面，自始至終，我們都只有一個index.html。","link":"/2023/03/27/VueRouter%E8%B7%B3%E9%A0%81%E7%BD%AE%E9%A0%82/"},{"title":"二元樹的走訪(Traversal)-廣度優先搜尋(BFS)","text":"二元樹的走訪(遍歷、Traversal)可以分為廣度優先搜尋和深度優先搜尋。 廣度優先搜尋(Breadth-First Search, BFS)廣度優先搜尋是以「層」為單位訪問二元樹的每一個節點，較容易找到離根結點(root)比較近的節點。以下圖為例，訪問的順序為：[1,2,5,3,4] leetcode Binary Tree Level Order Traversal12Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]] 解法 透過queue解123456789101112131415161718192021222324252627282930313233var levelOrder = function(root) { if (!root) { return []; } const result = []; const queue = [root]; while (queue.length) { /*透過queue來做遍歷，所以只要queue裡面還有值，就會繼續走*/ const levelSize = queue.length; /*紀錄queue的長度，之所以需要紀錄長度是因為在廣度搜尋的情況下，我們要知道這一層有幾個。queue的長度會動態改變，所以將這一層的節點有幾個記錄下來，可以確保我們不會把下一層的節點放入現在這層的陣列裡面。*/ const currentLevel = []; /*紀錄層級*/ for (let i = 0; i &lt; levelSize; i++) { /*以長度為條件跑回圈將節點放入陣列裡面，並把左右節點放入queue，並把這一層的array放入result裡面。*/ const node = queue.shift(); /*取出頭部的節點*/ currentLevel.push(node.val); /*放入這一層的陣列中*/ if (node.left) { queue.push(node.left); } if (node.right) { queue.push(node.right); } /*將取出節點的左右節點放入queue*/ } result.push(currentLevel); /*把這一層的array放入result裡面*/ } return result;}; 參考資料：代碼隨想錄算法訓練營","link":"/2023/04/22/%E4%BA%8C%E5%85%83%E6%A8%B9%E7%9A%84%E8%B5%B0%E8%A8%AA-Traversal-%E5%BB%A3%E5%BA%A6%E5%84%AA%E5%85%88%E6%90%9C%E5%B0%8B-BFS/"},{"title":"使用css變數控制字體大小","text":"** 本文前端程式碼使用vue3框架** 可以直接從左方目錄看「:root解法」 現代網頁基本都是RWD網頁，在不用擔心使用者放大/縮小會破版的情況下，透過em/rem設定字體大小，就可以因應使用者想要調整放大字體的需求。(使用者如果使用電腦，透過瀏覽器不斷放大網頁，就會使width變小，有rwd的情況下就會切換成mobile模式。) 但偶爾還是會有需要讓使用者自主選擇字體大小的情況，這種使用場景在文字閱讀類的網頁最容易看見，他們會設置小字、中字、大字的button讓使用者自由控制閱讀的文字大小。 不過這種情況通常是針對文本內容，而非整個網站設計，所以只要更改單一個區塊的字體大小就好了，可以簡單透過更改該div的style或是class做到。 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;changeFontSize('small')&quot;&gt;小&lt;/button&gt; &lt;button @click=&quot;changeFontSize('medium')&quot;&gt;中&lt;/button&gt; &lt;button @click=&quot;changeFontSize('large')&quot;&gt;大&lt;/button&gt; &lt;div :style=&quot;{ fontSize: fontSize + 'px' }&quot;&gt; &lt;p&gt;文字們&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import { ref } from 'vue';const fontSize = ref(20); const changeFontSize = (size) =&gt; { switch (size) { case 'small': fontSize.value = 18; break; case 'medium': fontSize.value = 20; break; case 'large': fontSize.value = 22; break; default: break; }};&lt;/script&gt; 不過如果是整個網站的內容都要更改呢？ 這時候每一種選項的字體大小會有很多種，比如large這個版本，不同的區塊可能使用了18px、22px、26px…的文字大小，如果再使用原本的方法，就會變得凌亂而複雜。 這種情況可以透過使用class來調整： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;changeFontSize('small')&quot;&gt;小&lt;/button&gt; &lt;button @click=&quot;changeFontSize('medium')&quot;&gt;中&lt;/button&gt; &lt;button @click=&quot;changeFontSize('large')&quot;&gt;大&lt;/button&gt; &lt;div :class=&quot;{ small: isSmall, medium: isMedium, large: isLarge }&quot;&gt; &lt;p class=&quot;font-a&quot;&gt;文字們&lt;/p&gt; &lt;p class=&quot;font-b&quot;&gt;文字們&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.small { .font-a { font-size: 18px; } .font-b { font-size: 20px; }}.medium { .font-a { font-size: 20px; } .font-b { font-size: 22px; }}.large { .font-a { font-size: 22px; } .font-b { font-size: 24px; }}&lt;/style&gt;&lt;script setup&gt;import { ref } from 'vue';const isSmall = ref(false);const isMedium = ref(true); //一開始設為中等const isLarge = ref(false);const changeFontSize = (size) =&gt; { isSmall.value = size === 'small'; isMedium.value = size === 'medium'; isLarge.value = size === 'large';};&lt;/script&gt; :root解法但，其實有更好的做法，就是透過:root和css的變數。透過:root，我們可以設置css的全域變數。:root用來選擇&lt;html&gt;這個標籤，是一個偽類，除了優先級大於&lt;html&gt;以外，跟&lt;html&gt;是相同的。 123:root { --main-color: red;} 並且我們可以透過js來修改css變數。 1document.documentElement.style.setProperty(&quot;--main-color&quot;, &quot;black&quot;); 因此，我們就可以透過:root加上js來設置整個網頁的字體大小調整。 1234567891011121314:root { --font-size-base:18px;}.font-a{ font-size: calc( 1.2 * var(--font-size-base));}.font-b{ font-size: calc( 1 * var(--font-size-base));}.font-c{ font-size: calc( 0.8 * var(--font-size-base));}//如果想要更多種就繼續往下加入 123456789101112131415161718192021222324252627&lt;script setup&gt;import { ref } from 'vue';const baseSize = ref('middle');const setSize = async (size) =&gt; { selectedSize.value = size; if (size == 'small') { document.documentElement.style.setProperty(&quot;--font-size-base&quot;, &quot;16px&quot;); } else if (size == 'middle') { document.documentElement.style.setProperty(&quot;--font-size-base&quot;, &quot;18px&quot;); } else if (size == 'large') { document.documentElement.style.setProperty(&quot;--font-size-base&quot;, &quot;20px&quot;); }};&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;setSize('small')&quot;&gt;小&lt;/button&gt; &lt;button @click=&quot;setSize('middle')&quot;&gt;中&lt;/button&gt; &lt;button @click=&quot;setSize('large')&quot;&gt;大&lt;/button&gt; &lt;/div&gt; &lt;div &gt; &lt;p class=&quot;font-a&quot;&gt;文字們&lt;/p&gt; &lt;p class=&quot;font-b&quot;&gt;文字們&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 除了精簡程式碼以外，這樣做最大的好處是，因為他是直接修改:root，所以可以影響整個html頁面，不用擔心在切割component的時候會有任何的遺漏，也不再需要去綁定class造成更多閱讀上的困難和修改維護上的混亂。","link":"/2023/11/28/%E4%BD%BF%E7%94%A8css%E8%AE%8A%E6%95%B8%E6%8E%A7%E5%88%B6%E5%AD%97%E9%AB%94%E5%A4%A7%E5%B0%8F/"},{"title":"給前端新手的ASP-NET科普","text":"作為只有淺學過php的前端仔，初出茅廬的時候，整個ASP.NET的生態就是我的知識盲區。 當然，工程師最大的才能就是google(現在還有chatgpt)。 然而，我還是聽不懂後端們的討論內容：：這是之前XX的案子，十幾年前了，還是用webform寫的。：我們之前都是用framwork，但你要用core也可以。：不然寫webAPI就好了，讓小郭寫前端打API來撈資料。：之後要請你維護一下OO案，他們是用MVC，你可能要摸一下。 終於，再費盡九牛二虎之力之後，我終於(應該)懂了！ 那就讓我娓娓道來這曲折迂迴的故事。 希望透過這篇文章，可以讓大家對於各種專有名詞有些基礎的了解，如果想要開始撰寫.NET，也有了一些開始的方向。 Framework vs Core.NET Framework是什麼？#####.NET Framework是一個微軟出產的軟體框架，一般來說只會在windows的環境上開發，搭配C#、F#、VB等語言。可以用來開發應用程式(WinForms、WPF)、網頁(Web)，其中網頁又有Web Form、MVC、webAPI這三種常見的架構。.NET Framework4.8是.NET Framework的最後一個版本，微軟表示會繼續維護.NET Framework，但新的開發，建議使用.NET Core .NET Core是什麼？上面提到.NET Framework是基於Windows的開發框架，所以為了支援不同的平台(Mac Linux)，這邊要注意一下，.NET core有不同的版本： .NET core 3 ：.NET core 3以及3以前的版本已經停止支援了，也是最後叫做.NET core的一代，在3之後，.NET core就直接叫做.NET了，並且跳過4直接到5。 .NET 5 ：在這之後的.NET core版本都會直接以.NET+數字表示，但為了區分Framework，實務上還是會提一下是.NET core，不過因為Framework最高版本只有4.8，所以5以上必然就會是.NET core。另外，.NET 5 也已經在2022 年 5 月停止支援了。(BTW，從XBOX開始，我就覺得微軟的命名邏輯超難懂的^^) .NET 6 ：現在(2023)穩定版本的.NET，在.NET 6之後，範本就不會有Startup.cs了，所以在google抄code的時候，如果看到Startup，就表示你找到的是.NET 5 的範例囉。 有了綜觀的了解之後，就來記錄一下我自己當初的一些疑惑。 .NET 跟 C#是同一個東西嗎？###不同。不過都是微軟爸爸旗下的產品。 .NET.NET是一個開發框架，可以用C#、F#、VB、C++/CLI來寫，據說早期有VB vs C#的戰爭，不過菜鳥我入行以來，遇到的都是基於C#來寫的.NET。 C#C#是一種程式語言，就跟C++/java一樣，除了拿來撰寫.NET，也常見於開發遊戲(Unity)。 不過實務上，基本上就是C#+.NET+VS微軟爸爸的全家桶吃到飽拉。 Web Form、MVC、webAPIWeb Form一個古老(誤)的開發網頁的架構，透過後端生成html，副檔名是aspx。操作上可以透過拖拉來撰寫html。比如buuton可以用圖形化介面「拉」出來，而不需要寫&lt;button&gt;&lt;button&gt;。 MVCMVC是一種分層式的軟體開發架構，將軟體分為Model、View、Controller三個區塊。 Model：操作一些連接資料庫數據的邏輯。 Controller：處理請求，比如我進入首頁這件事情，可能就是HomeController在控制路由，並且去跟Model拿資料。 View：顯示畫面，如果寫Razor的話，附檔名是.cshtml。 基本上以「純」前端工程師來說，應該是不會直接撰寫到完整的MVC，以我粗淺的理解，我認為MVC在開發網站的時候，更像是以後端出發，將資料送出來，然後透過View做一些排版上面的美化，呈現給使用者。 webAPIwebAPI就是一個純粹提供資料的接口。後端只負責提供查找數據、處理請求，不負責渲染畫面。在這個情況下，後端跟前端可以分屬不同的網域、不同的站台，也因此前端後端可以各司其職，分離工作。 Razor是一種將C#的程式嵌入html的語法，方便將一些動態的資料綁訂到html上面。，以下截取一段以Razor寫的cshtml，跑一個foreach，把item裡面的資料綁訂到&lt;td&gt;裡面(作為一個前端仔，覺得跟vue的概念跟這個滿類似的。) 1234567891011121314@foreach (var item in Model){ &lt;tr&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.fEmpId) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.fName) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.fMail) &lt;/td&gt; &lt;/tr&gt;} 那麼，名詞解釋完畢後，作為一個前端工程師或是沒接觸過寫程式的菜鳥，該怎麼入門.NET呢？ 我建議，先從C#學起。 先從C#學起，不使用任何框架，單純的使用console練習，學會C#的語法以及基礎的物件導向、類別、繼承等等的概念。 在console的環境下，用ADO.NET連接資料庫，理解後端&gt;資料庫這段程式與邏輯。 直接進入.NET 6，以webAPI為第一個學習的框架。在不串接資料庫的情況下，理解打API到後端接受請求這段程式與邏輯。 在webAPI的框架下，完成後端撈取資料庫資料、提供API這一整個架構的程式與邏輯。 學習MVC，可以透過RAZOR提供的CRUD範本，將view的概念帶進來。","link":"/2023/03/25/%E7%B5%A6%E5%89%8D%E7%AB%AF%E6%96%B0%E6%89%8B%E7%9A%84ASP-NET%E7%A7%91%E6%99%AE/"},{"title":"資料結構-二元樹Binary tree(1)","text":"二元樹是一種特殊的樹狀結構，應用很廣，Heap就是一種二元樹。最大的特色就是每個節點最多兩個分支(節點)，每個節點會記錄自己的值、左節點、右節點。 二元樹的定義 每個節點最多兩個分支，但也可以空集合，也就是節點分支度&gt;0且&lt;=2 節點左邊是左子樹(left child)、右邊是右子樹(right child)，子樹的左右次序不能夠隨意顛倒。 左子樹和右子樹也分別都是一棵二元樹 和樹的比較 樹 二元樹 結構 可以有無限多個節點 每個節點最多只有兩個子節點 可否為空 不可以為空集合 可以為空樹 節點的排列 左右無排序 左右有序 二元樹的基礎種類 歪斜樹（Skewed Tree）：完全沒有左邊節點或是右邊節點的二元樹，集中左邊是左歪斜樹、集中右邊是右歪斜樹。 完全二元樹（Complete Binary Tree）：所有層級都填滿節點，最後一層節點可以不滿，但必須從左至右填入節點。 完滿二元樹（Full Binary Tree）：所有節點都有兩個子節點，除了葉子節點。即：要有子節點，就要兩個，不然就通通不要。 完美二元樹 ( Perfect Binary Tree )：各層節點全滿。同時也是 full binary tree 和 complete binary tree 。 二元樹的常見類型 平衡二元樹（Balanced Binary Tree）：左右子樹的高度差不超過1。 二元搜索樹（Binary Search Tree）：所有左子樹中的節點值都小於其父節點的值，而所有右子樹中的節點值都大於其父節點的值。 二元樹的走訪 前序(leetcode 144) 中序(leetcode 94) 後序(leetcode 145) 層序(leetcode 102)","link":"/2023/04/02/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%85%83%E6%A8%B9Binary%20tree-1/"},{"title":"踩雷實錄 - UTF8 with BOM","text":"最近維護一個MVC架構的專案，使用的是.net framework4.7。 在新建一個cshtml(Razor)的時候，出現html的中文出現亂碼的情況，而且有趣的是，如果這個「中文」是從@model引入的，反而就不會亂碼。 第一瞬間認為是編碼問題，但檔案是UTF-8沒錯，後來才發現，是UTF-8跟UTF-8 with BOM的差異。 BOM(byte-order mark)是位元組順序記號，用來標記現在編碼的一些順序資訊、要怎麼解讀。而UTF-8只有單字節，所以通常不需要帶BOM，UTF-16/UTF32才需要帶BOM。以「A」為例： 編碼 字節順序(帶BOM) 值 UTF-8 41 UTF-16 大端序(BE) 00 41 UTF-16 小端序(LE) 41 00 UTF-32 大端序(BE) 00 00 00 41 UTF-32 小端序(LE) 41 00 00 00 BUT，就是這個BUT，我產出不帶BOM的.cshtml的時候卻出現了亂碼，回頭一看，專案原本的.cshtml都帶BOM。我查了一下，雖然不含BOM的UTF-8才是標準的形式，但微軟的某些環境會帶BOM，比如visul studio。(經過實測，用vs開啟一個.framework的MVC專案，預設生成的_ViewStart.cshtml就是UTF-8 with BOM) 至於微軟為什麼要這麼做，我沒有查到明確答案，不過確實也有其他人遇到這個問題，網路上也有解法可以讓Razor without BOM，不過我個人就是繼續with BOM。![[Pasted image 20231030164737.png]] 下次如果大家出現亂碼，編碼又乍看沒問題的話，可以看看是不是BOM這邊踩雷了。 參考資料： https://tech.gjlmotea.com/2021/06/big-endian-little-endianbom-fffe-feff.html https://www.zhihu.com/question/20167122 https://stackoverflow.com/questions/24431985/how-do-i-make-razor-read-utf-8-files-without-bom","link":"/2023/10/30/%E8%B8%A9%E9%9B%B7%E5%AF%A6%E9%8C%84-UTF8-with-BOM/"},{"title":"UnoCSS初探","text":"作為一個不喜歡使用css框架的造輪工人，一直以來對於Bootstrap和Tailwind這類的框架，都是非必要不使用，主要原因大概如下： 不易閱讀這點滿見仁見智的，主要就是我覺得寫在html的css閱讀上很不清晰，維護也比較困難 學習曲線與直覺性很多時候我覺得使用上其實不直覺，舉Tailwind為例，w-4是width: 1rem，也就是說，我們需要先學習它的w-4=width: 1rem；然後再開始計算。同時w-1/6是width: 16.666667%，但100%卻是w-full。 缺失的class按照上面width的邏輯，我今天想要2.75rem的話，算一下，是w-11。那如果2.8rem呢？沒有，ない！有時候就會遇到這種以為有這個class，但其實沒有的情況。當然！Tailwind可以自定義Class名稱，我們可以自己去設定檔建立一個w-11.2的名稱。不過如果我甚麼都要自己建立一個class，我幹嘛不要自己寫css就好了？ UnoCSS的誕生，雖然不能解決第一個inline的問題(應該說只要不想寫css，就不可避免地要寫inline，這就是取捨)，但卻可以有效的解決第二與第三個問題。 甚麼是UnoCSS?UnoCSS(下文接簡寫UNO)官網開衝名義就寫了：UnoCSS is the instant atomic CSS engine，對比TailWind：A utility-first CSS framework packed。兩者其實是很不一樣的東西，UNO是引擎；TailWind是框架，那麼，引擎跟框架會有差嗎？ 透過正則表達式生成規則UNO的使用正則表達式(RegExp)來定義與提供使用者自定義Class，此時新增的並非是一個Class，而是一種Class規則，之後不論是m-1還是m-8.787都可以用來設置margin。這除了讓自定義變得容易以外，同時也代表了，我們只需要生成我們真的有用到的Class就好了，而不需要在開發的時候就先擁有一大包已經被定義好Class的檔案，因此它很輕量。文件宣稱了它只要 ~6kb min+brotli ：Zero deps and browser friendly: ~6kb min+brotli 12345678// UNO官網例子// uno.config.tsexport default defineConfig({ rules: [- ['m-1', { margin: '1px' }]+ [/^m-([\\.\\d]+)$/, ([_, num]) =&gt; ({ margin: `${num}px` })], ],}) 兼容各種寫法UNO在Github上寫下，UNO受到了ACSS、Bootstrap、Tailwind CSS、Windi CSS……等的啟發。因此，站在巨人的肩膀上，UNO的寫法基本上兼融了這些前浪們的寫法，以width為例，你可以：w-1rem、w-100px、w--0、w-full、w-3xl，基本上你習慣怎麼寫，在UNO上面都可以輕鬆的應用，你不需要重新學習一套新的CSS框架，就可以輕鬆使用。 真的這麼好嗎？不過，UNO這種生成式的寫法，以及集大成的Class，某種程度來說，反而對於完全沒寫過任何框架的新手不怎麼友善，它採用互動式文檔，優點是找甚麼東西都很快，缺點是，可能不知道從何找起。 我如果在Tailwind上找RWD，他會很清楚的給我斷點的Class，以及用法。 但我如果透過UNO的互動文件，我根本不知道該怎麼辦。 不過UNO也很好心的告訴你了：他預設文件的規則： This preset is compatible with Tailwind CSS and Windi CSS, you can refer to their documentation for detailed usage.For all rules and presets included in this preset, please refer to our interactive docs or directly go to the source code. 如果你不知道怎麼寫，可以參考一下Tailwind CSS和Windi CSS，我們沿用了他們的寫法。 於是，當我不知道該怎麼用的時候，我就可以去Tailwind CSS查一下，然後回來UNO用，也算是非常方便了。 總結UNO的優點顯而易見，輕量、兼容性強、輕鬆自定義，未來如果我真的要使用CSS框架/引擎，應該就會以UNO優先。另外，他也還有一些其他的寫法，比如寫在組件裡面、主題模式等等，這部分之後在開發時如果有使用也可以分享。那麼，就附上他的官網跟互動式文檔囉：https://unocss.dev/https://unocss.dev/interactive/","link":"/2023/11/29/UnoCSS%E5%88%9D%E6%8E%A2/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"Object.keys","slug":"Object-keys","link":"/tags/Object-keys/"},{"name":"渲染","slug":"渲染","link":"/tags/%E6%B8%B2%E6%9F%93/"},{"name":"v-for","slug":"v-for","link":"/tags/v-for/"},{"name":"VueRouter","slug":"VueRouter","link":"/tags/VueRouter/"},{"name":"路由","slug":"路由","link":"/tags/%E8%B7%AF%E7%94%B1/"},{"name":"SPA","slug":"SPA","link":"/tags/SPA/"},{"name":"MPA","slug":"MPA","link":"/tags/MPA/"},{"name":"資料結構","slug":"資料結構","link":"/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"},{"name":"二元樹","slug":"二元樹","link":"/tags/%E4%BA%8C%E5%85%83%E6%A8%B9/"},{"name":"css變數","slug":"css變數","link":"/tags/css%E8%AE%8A%E6%95%B8/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":":root","slug":"root","link":"/tags/root/"},{"name":"字體大小","slug":"字體大小","link":"/tags/%E5%AD%97%E9%AB%94%E5%A4%A7%E5%B0%8F/"},{"name":".NET","slug":"NET","link":"/tags/NET/"},{"name":".NET core","slug":"NET-core","link":"/tags/NET-core/"},{"name":".NET Framework","slug":"NET-Framework","link":"/tags/NET-Framework/"},{"name":"webAPI","slug":"webAPI","link":"/tags/webAPI/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"UTF8","slug":"UTF8","link":"/tags/UTF8/"},{"name":"BOM","slug":"BOM","link":"/tags/BOM/"},{"name":"Razor","slug":"Razor","link":"/tags/Razor/"},{"name":"UnoCSS","slug":"UnoCSS","link":"/tags/UnoCSS/"},{"name":"TailWind","slug":"TailWind","link":"/tags/TailWind/"},{"name":"css框架","slug":"css框架","link":"/tags/css%E6%A1%86%E6%9E%B6/"}],"categories":[{"name":"程式筆記","slug":"程式筆記","link":"/categories/%E7%A8%8B%E5%BC%8F%E7%AD%86%E8%A8%98/"},{"name":"資料結構","slug":"資料結構","link":"/categories/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"}],"pages":[{"title":"about","text":"我是chin","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}