{"posts":[{"title":"給前端新手的ASP-NET科普","text":"作為只有淺學過php的前端仔，初出茅廬的時候，整個ASP.NET的生態就是我的知識盲區。 當然，工程師最大的才能就是google(現在還有chatgpt)。 然而，我還是聽不懂後端們的討論內容：：這是之前XX的案子，十幾年前了，還是用webform寫的。：我們之前都是用framwork，但你要用core也可以。：不然寫webAPI就好了，讓小郭寫前端打API來撈資料。：之後要請你維護一下OO案，他們是用MVC，你可能要摸一下。 終於，再費盡九牛二虎之力之後，我終於(應該)懂了！ 那就讓我娓娓道來這曲折迂迴的故事。 希望透過這篇文章，可以讓大家對於各種專有名詞有些基礎的了解，如果想要開始撰寫.NET，也有了一些開始的方向。 Framework vs Core.NET Framework是什麼？#####.NET Framework是一個微軟出產的軟體框架，一般來說只會在windows的環境上開發，搭配C#、F#、VB等語言。可以用來開發應用程式(WinForms、WPF)、網頁(Web)，其中網頁又有Web Form、MVC、webAPI這三種常見的架構。.NET Framework4.8是.NET Framework的最後一個版本，微軟表示會繼續維護.NET Framework，但新的開發，建議使用.NET Core .NET Core是什麼？上面提到.NET Framework是基於Windows的開發框架，所以為了支援不同的平台(Mac Linux)，這邊要注意一下，.NET core有不同的版本： .NET core 3 ：.NET core 3以及3以前的版本已經停止支援了，也是最後叫做.NET core的一代，在3之後，.NET core就直接叫做.NET了，並且跳過4直接到5。 .NET 5 ：在這之後的.NET core版本都會直接以.NET+數字表示，但為了區分Framework，實務上還是會提一下是.NET core，不過因為Framework最高版本只有4.8，所以5以上必然就會是.NET core。另外，.NET 5 也已經在2022 年 5 月停止支援了。(BTW，從XBOX開始，我就覺得微軟的命名邏輯超難懂的^^) .NET 6 ：現在(2023)穩定版本的.NET，在.NET 6之後，範本就不會有Startup.cs了，所以在google抄code的時候，如果看到Startup，就表示你找到的是.NET 5 的範例囉。 有了綜觀的了解之後，就來記錄一下我自己當初的一些疑惑。 .NET 跟 C#是同一個東西嗎？###不同。不過都是微軟爸爸旗下的產品。 .NET.NET是一個開發框架，可以用C#、F#、VB、C++/CLI來寫，據說早期有VB vs C#的戰爭，不過菜鳥我入行以來，遇到的都是基於C#來寫的.NET。 C#C#是一種程式語言，就跟C++/java一樣，除了拿來撰寫.NET，也常見於開發遊戲(Unity)。 不過實務上，基本上就是C#+.NET+VS微軟爸爸的全家桶吃到飽拉。 Web Form、MVC、webAPIWeb Form一個古老(誤)的開發網頁的架構，透過後端生成html，副檔名是aspx。操作上可以透過拖拉來撰寫html。比如buuton可以用圖形化介面「拉」出來，而不需要寫&lt;button&gt;&lt;button&gt;。 MVCMVC是一種分層式的軟體開發架構，將軟體分為Model、View、Controller三個區塊。 Model：操作一些連接資料庫數據的邏輯。 Controller：處理請求，比如我進入首頁這件事情，可能就是HomeController在控制路由，並且去跟Model拿資料。 View：顯示畫面，如果寫Razor的話，附檔名是.cshtml。 基本上以「純」前端工程師來說，應該是不會直接撰寫到完整的MVC，以我粗淺的理解，我認為MVC在開發網站的時候，更像是以後端出發，將資料送出來，然後透過View做一些排版上面的美化，呈現給使用者。 webAPIwebAPI就是一個純粹提供資料的接口。後端只負責提供查找數據、處理請求，不負責渲染畫面。在這個情況下，後端跟前端可以分屬不同的網域、不同的站台，也因此前端後端可以各司其職，分離工作。 Razor是一種將C#的程式嵌入html的語法，方便將一些動態的資料綁訂到html上面。，以下截取一段以Razor寫的cshtml，跑一個foreach，把item裡面的資料綁訂到&lt;td&gt;裡面(作為一個前端仔，覺得跟vue的概念跟這個滿類似的。) 1234567891011121314@foreach (var item in Model){ &lt;tr&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.fEmpId) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.fName) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.fMail) &lt;/td&gt; &lt;/tr&gt;} 那麼，名詞解釋完畢後，作為一個前端工程師或是沒接觸過寫程式的菜鳥，該怎麼入門.NET呢？ 我建議，先從C#學起。 先從C#學起，不使用任何框架，單純的使用console練習，學會C#的語法以及基礎的物件導向、類別、繼承等等的概念。 在console的環境下，用ADO.NET連接資料庫，理解後端&gt;資料庫這段程式與邏輯。 直接進入.NET 6，以webAPI為第一個學習的框架。在不串接資料庫的情況下，理解打API到後端接受請求這段程式與邏輯。 在webAPI的框架下，完成後端撈取資料庫資料、提供API這一整個架構的程式與邏輯。 學習MVC，可以透過RAZOR提供的CRUD範本，將view的概念帶進來。","link":"/2023/03/25/%E7%B5%A6%E5%89%8D%E7%AB%AF%E6%96%B0%E6%89%8B%E7%9A%84ASP-NET%E7%A7%91%E6%99%AE/"},{"title":"VueRouter跳頁置頂","text":"如果沒有特別設定，Vue使用Vue Router跳頁的時候，並不會自動置頂，而是會跳轉到原本瀏覽頁面的位置。 解法為了解決這個問題，可以手動設置router一但被觸發，就自動將畫面滾動到置頂處。在main.js裡面加入這行程式碼，記得要先引用router。 1234import router from &quot;./router&quot;;router.afterEach((to, from, next) =&gt; { window.scrollTo(0, 0);}); 原理討論那麼，為什麼會有這樣的狀況？ 透過Vue Router，我們可以讓我們透過Vue建置的單頁應用程式(SPA) 實現前端路由，但實際上，我們並沒有跳轉到另一個頁面去，我們只是重新渲染了現在這個頁面，所以我們的瀏覽器頁面位置會停留在原來的高度。 MPA與後端路由在多頁應用程式(MPA)，我們透過後端來控制路由，當我們要替換頁面的時候，會跟後端請求一個新的頁面(xxx.html)，後端接收到請求，將使用者的瀏覽器跳轉到另一頁，也因此我們有多頁。 SPA與前端路由Vue Router則是使用了 Html5的History API來控制路由，透過history.pushState()將新的路由狀態添加到瀏覽器的歷史紀錄，然後改變網址。但我們沒有請求一個新的頁面，也沒有創造出一個新的頁面，而是在原本的頁面渲染出不同的資料畫面，自始至終，我們都只有一個index.html。","link":"/2023/03/27/VueRouter%E8%B7%B3%E9%A0%81%E7%BD%AE%E9%A0%82/"},{"title":"資料結構-二元樹Binary tree(1)","text":"二元樹是一種特殊的樹狀結構，應用很廣，Heap就是一種二元樹。最大的特色就是每個節點最多兩個分支(節點)，每個節點會記錄自己的值、左節點、右節點。 二元樹的定義 每個節點最多兩個分支，但也可以空集合，也就是節點分支度&gt;0且&lt;=2 節點左邊是左子樹(left child)、右邊是右子樹(right child)，子樹的左右次序不能夠隨意顛倒。 左子樹和右子樹也分別都是一棵二元樹 和樹的比較 樹 二元樹 結構 可以有無限多個節點 每個節點最多只有兩個子節點 可否為空 不可以為空集合 可以為空樹 節點的排列 左右無排序 左右有序 二元樹的基礎種類 歪斜樹（Skewed Tree）：完全沒有左邊節點或是右邊節點的二元樹，集中左邊是左歪斜樹、集中右邊是右歪斜樹。 完全二元樹（Complete Binary Tree）：所有層級都填滿節點，最後一層節點可以不滿，但必須從左至右填入節點。 完滿二元樹（Full Binary Tree）：所有節點都有兩個子節點，除了葉子節點。即：要有子節點，就要兩個，不然就通通不要。 完美二元樹 ( Perfect Binary Tree )：各層節點全滿。同時也是 full binary tree 和 complete binary tree 。 二元樹的常見類型 平衡二元樹（Balanced Binary Tree）：左右子樹的高度差不超過1。 二元搜索樹（Binary Search Tree）：所有左子樹中的節點值都小於其父節點的值，而所有右子樹中的節點值都大於其父節點的值。 二元樹的走訪 前序(leetcode 144) 中序(leetcode 94) 後序(leetcode 145) 層序(leetcode 102)","link":"/2023/04/02/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B-%E4%BA%8C%E5%85%83%E6%A8%B9Binary%20tree-1/"},{"title":"二元樹的走訪(Traversal)-廣度優先搜尋(BFS)","text":"二元樹的走訪(遍歷、Traversal)可以分為廣度優先搜尋和深度優先搜尋。 廣度優先搜尋(Breadth-First Search, BFS)廣度優先搜尋是以「層」為單位訪問二元樹的每一個節點，較容易找到離根結點(root)比較近的節點。以下圖為例，訪問的順序為：[1,2,5,3,4] leetcode Binary Tree Level Order Traversal12Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]] 解法 透過queue解123456789101112131415161718192021222324252627282930313233var levelOrder = function(root) { if (!root) { return []; } const result = []; const queue = [root]; while (queue.length) { /*透過queue來做遍歷，所以只要queue裡面還有值，就會繼續走*/ const levelSize = queue.length; /*紀錄queue的長度，之所以需要紀錄長度是因為在廣度搜尋的情況下，我們要知道這一層有幾個。queue的長度會動態改變，所以將這一層的節點有幾個記錄下來，可以確保我們不會把下一層的節點放入現在這層的陣列裡面。*/ const currentLevel = []; /*紀錄層級*/ for (let i = 0; i &lt; levelSize; i++) { /*以長度為條件跑回圈將節點放入陣列裡面，並把左右節點放入queue，並把這一層的array放入result裡面。*/ const node = queue.shift(); /*取出頭部的節點*/ currentLevel.push(node.val); /*放入這一層的陣列中*/ if (node.left) { queue.push(node.left); } if (node.right) { queue.push(node.right); } /*將取出節點的左右節點放入queue*/ } result.push(currentLevel); /*把這一層的array放入result裡面*/ } return result;}; 參考資料：代碼隨想錄算法訓練營","link":"/2023/04/22/%E4%BA%8C%E5%85%83%E6%A8%B9%E7%9A%84%E8%B5%B0%E8%A8%AA-Traversal-%E5%BB%A3%E5%BA%A6%E5%84%AA%E5%85%88%E6%90%9C%E5%B0%8B-BFS/"},{"title":"Vue3-使用object.keys渲染資料","text":"在使用v-for渲染資料的時候，偶爾會面臨一個問題：不是所有的data都需要顯示出來。 一般來說，我們渲染的data都是從後端API拉取的資料，以個人資料為例，拿到的資料可能是： 12345678{ &quot;name&quot;:&quot;chin&quot;, &quot;age&quot;:&quot;28&quot;, &quot;sex&quot;:&quot;女&quot;, &quot;phone&quot;:&quot;0900000000&quot;, &quot;address&quot;:&quot;台北府000路&quot;, &quot;type&quot;:&quot;黃金會員&quot;,} 然而實際需要呈現的資料可能只有其中兩三項，這時候善用object.keys就能夠有效的篩選想要呈現的data，而不需要使用v-if來一個一個呈現或是一個一個隱藏。 先建立想要呈現資訊的object12345678let tableHeadList = ref({ &quot;name&quot;:&quot;姓名&quot;, &quot;age&quot;:&quot;年齡&quot;, &quot;sex&quot;:&quot;性別&quot;, // &quot;phone&quot;:&quot;電話號碼&quot;, // &quot;address&quot;:&quot;地址&quot;, // &quot;type&quot;:&quot;類型&quot;,}) 取得Object.keys(tableHeadList)的key值後，渲染{{ data[key] }}123456789101112131415161718&lt;div class=&quot;body&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th v-for=&quot;key in Object.keys(tableHeadList)&quot;&gt; {{ tableHeadList[key] }} &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td v-for=&quot;key in Object.keys(tableHeadList)&quot;&gt; {{ data[key] }} &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 成功將想要呈現的資訊渲染在頁面上![[Pasted image 20231012155348.png]] 這樣的做法，還有另一項好處，就是如果想要根據不同的條件呈現不同的data，可以透過更改tableHeadList來達到 1234567891011onMounted(async() =&gt; { if(visible == 'A'){ tableHeadList.value = { &quot;name&quot;:&quot;姓名&quot;, &quot;age&quot;:&quot;年齡&quot;, &quot;sex&quot;:&quot;性別&quot;, &quot;phone&quot;:&quot;電話號碼&quot;, &quot;address&quot;:&quot;地址&quot;, } }}) 不過這樣的做法也有其缺點，因為標題的渲染和data的渲染是分開的，所以寬度跟文字寬度不一致的時候就會破版。 這時候，就需要稍微換一下html的結構，把標題和data放置在同一層的div裡面。 12345678910 &lt;div class=&quot;data-box&quot;&gt; &lt;div&gt; &lt;div v-for=&quot;(item,key) in tableHeadList&quot; &gt; &lt;p&gt;{{item}}&lt;/p&gt; &lt;div&gt; &lt;p&gt;{{data[key]}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;","link":"/2023/10/12/Vue3-%E4%BD%BF%E7%94%A8object-keys%E6%B8%B2%E6%9F%93%E8%B3%87%E6%96%99/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"VueRouter","slug":"VueRouter","link":"/tags/VueRouter/"},{"name":"路由","slug":"路由","link":"/tags/%E8%B7%AF%E7%94%B1/"},{"name":"SPA","slug":"SPA","link":"/tags/SPA/"},{"name":"MPA","slug":"MPA","link":"/tags/MPA/"},{"name":".NET","slug":"NET","link":"/tags/NET/"},{"name":".NET core","slug":"NET-core","link":"/tags/NET-core/"},{"name":".NET Framework","slug":"NET-Framework","link":"/tags/NET-Framework/"},{"name":"webAPI","slug":"webAPI","link":"/tags/webAPI/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"資料結構","slug":"資料結構","link":"/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"},{"name":"二元樹","slug":"二元樹","link":"/tags/%E4%BA%8C%E5%85%83%E6%A8%B9/"},{"name":"Object.keys","slug":"Object-keys","link":"/tags/Object-keys/"},{"name":"渲染","slug":"渲染","link":"/tags/%E6%B8%B2%E6%9F%93/"},{"name":"v-for","slug":"v-for","link":"/tags/v-for/"}],"categories":[{"name":"程式筆記","slug":"程式筆記","link":"/categories/%E7%A8%8B%E5%BC%8F%E7%AD%86%E8%A8%98/"},{"name":"資料結構","slug":"資料結構","link":"/categories/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"}],"pages":[{"title":"about","text":"我是chin","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}